use snarkvm_console_network::{Network, Testnet3};
use snarkvm_console_types::{Group, Scalar, U8, U64};
use snarkvm_console_types_scalar::{Uniform, FromField, ToField, Zero};

use rand::Rng;
use core::num;
use std::collections::HashMap;


// The public key used to verify a threshold signature made by a group of signers
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct GroupPublicKey (pub Group<Testnet3>);

// The signer's public key -- not really worth much
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerPublicKey (pub Group<Testnet3>);

// The signer's secret key -- sk_sig partial
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerSecretKey (pub Scalar<Testnet3>);

// The list of signer public keys and the group public key
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PublicKeys {
    // The map of all participant public keys.
    pub public_keys: HashMap<u64, SignerPublicKey>,
    // The group public key used to verify the final threshold signature
    pub group_public_key: GroupPublicKey,
}

// A signer's share that includes its secret key and all publicly known keys/commitments
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerShare {
    // The index of the participant.
    pub participant_index: u64,
    // The participant's secret key share
    pub secret_key: SignerSecretKey,
    // The participant's public key corresponding to their secret key share
    pub public_key: SignerPublicKey,
    // The group public key used to verify the final threshold signature
    pub group_public_key: GroupPublicKey,
    // The public commitments to the coefficients (generated by each participant)
    pub commitment: Vec<Group<Testnet3>>
}

impl SignerShare {
    // Verify that the secret share was generated correctly and matches the commitment
    pub fn is_valid(&self) -> bool {
        let expected_result = Network::g_scalar_multiply(&self.secret_key.0);

        let index_scalar = Scalar::<Testnet3>::from_field(&U64::new(self.participant_index).to_field().unwrap()).unwrap();
        let mut result = Group::<Testnet3>::zero();
        for (i, c) in self.commitment.iter().rev().enumerate() {
            result = result + c;

            if i != self.commitment.len() - 1 {
                result = result * index_scalar;
            }
        }

        expected_result == result
    }
    
}

/// Generates the participant keys using a trusted authority/dealer (can also be done with DKG)
/// 
/// The trusted dealer model only generates a single polynomial for all participants
/// More specifically,
/// - Interprets [secret, coefficients[0], ...] as secret polynomial f
/// - For each participant i, their secret share is f(i)
/// - The commitment to the secret polynomial f is [g^secret, g^coefficients[0],...]
///  
/// The 'secret' is input as the sk_sig of a previously generated account
/// g^sk_sig = GroupPublicKey = pk_sig
pub fn trusted_keygen<R: Rng> (
    num_participants: u8,
    threshold: u8,
    secret: &Scalar<Testnet3>,
    rng: &mut R,
) -> (Vec<SignerShare>, PublicKeys) {
    if num_participants < 1 {
        panic!("the number of participants must be greater than 0.")
    }

    if threshold < 1 || threshold > num_participants {
        panic!("the threshold must be between 1 and num_participants");
    }

    let mut coefficients: Vec<Scalar<Testnet3>> = Vec::with_capacity(threshold as usize);
    let mut share_commitment: Vec<Group<Testnet3>> = Vec::with_capacity(threshold as usize);

    // FROST KeyGen Round 1.1: Generate the polynomial coefficients from secret and rng
    coefficients.push(*secret);
    for _ in 0..threshold - 1 {
        coefficients.push(Scalar::<Testnet3>::rand(rng));
    }

    // Skipping proof of knowledge of first coefficient (TODO?)

    // FROST Keygen Round 1.3: Generate the public commitments.
    for coeff in &coefficients {
        share_commitment.push(Network::g_scalar_multiply(coeff));
    }

    // Generate the group public key used to verify the final threshold signature from the secret key
    let group_public_key = Network::g_scalar_multiply(secret);

    // FROST Keygen Round 2: Generate the secret shares for each participant using a centralized authority
    let mut shares = Vec::with_capacity(num_participants as usize);
    let mut participant_public_keys: HashMap<u64, SignerPublicKey> = HashMap::with_capacity(num_participants as usize);

    // Evaluate the polynomial f at point 'index' to generate secret shares.
    // Using Horner's Method
    for index in 1..num_participants +1 {
        let index_scalar = Scalar::<Testnet3>::from_field(&U8::new(index).to_field().unwrap()).unwrap();
        let mut result = Scalar::<Testnet3>::zero();
        for (i, coeff) in coefficients.iter().rev().enumerate() {
            result = result + coeff;

            if i != coefficients.len() - 1 {
                result = result * index_scalar;
            }
        }

        let public_key= Network::g_scalar_multiply(&result);

        let secret_share = SignerShare {
            participant_index: index as u64,
            secret_key: SignerSecretKey(result),
            public_key: SignerPublicKey(public_key.clone()),
            group_public_key: GroupPublicKey(group_public_key.clone()),
            commitment: share_commitment.clone(),
        };

        participant_public_keys.insert(index as u64, SignerPublicKey(public_key));
        shares.push(secret_share);
    }

    let public_keys = PublicKeys { public_keys: participant_public_keys, group_public_key: GroupPublicKey(group_public_key) };

    (shares, public_keys)


}

pub fn reconstruct_secret(
    participants: &[SignerShare]
) -> SignerSecretKey {
    let indexes: &[u64] = participants.iter().map(|p| p.participant_index).collect()::Vec<_>>();

    let mut reconstructed_secret = Scalar::<Testnet3>::zero();

    for participant in participants {
        let coeff = calculate_lagrange_coefficients(participant.participant_index, &indexes)?;

        reconstructed_secret = reconstructed_secret + participant.secret_key.0 * coeff;
    }

    Ok(SignerSecretKey(reconstructed_secret))
}